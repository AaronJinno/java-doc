import{_ as a,o as e,c as r,e as i}from"./app-77176646.js";const s="/java-doc/img/sql/es/5-7-1.jpg",c={},t=i('<h2 id="文档冲突介绍" tabindex="-1"><a class="header-anchor" href="#文档冲突介绍" aria-hidden="true">#</a> 文档冲突介绍</h2><h4 id="_1-冲突产生原因" tabindex="-1"><a class="header-anchor" href="#_1-冲突产生原因" aria-hidden="true">#</a> 1. 冲突产生原因</h4><p>当对文档进行修改时，会读取原文档，修改后，会重新索引新文档。不过ES的修改并非是单线程的，可能存在多个人同时修改文档。</p><p>虽然ES储存的只是提供于搜索的数据，主要数据存在于MySQL，且同时修改一个文档的概率很小。但某些场景下非常影响体验。</p><h4 id="_2-场景示例" tabindex="-1"><a class="header-anchor" href="#_2-场景示例" aria-hidden="true">#</a> 2. 场景示例</h4><p>比如一个商品促销场景，使用 Elasticsearch 存储商品库存的数量， 每卖一个商品的时候，Elasticsearch 中将库存数量减少（促销场景下，一秒钟会卖出很多）。</p><p>如下图：产生了多个web程序修改ES的场景</p><figure><img src="'+s+'" alt="5-7-1" tabindex="0" loading="lazy"><figcaption>5-7-1</figcaption></figure><p>问题：web_1 对 stock_count 所做的更改已经丢失，因为 web_2 不知道它的 stock_count 的拷贝已经过期。 结果我们会认为有超过商品的实际数量的库存，因为卖给顾客的库存商品并不存在。</p><p>变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。</p><h4 id="_3-解决方案" tabindex="-1"><a class="header-anchor" href="#_3-解决方案" aria-hidden="true">#</a> 3. 解决方案</h4><p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p><ul><li>悲观并发控制：这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</li><li>乐观并发控制：Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何<br> 解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</li></ul><h2 id="乐观并发控制" tabindex="-1"><a class="header-anchor" href="#乐观并发控制" aria-hidden="true">#</a> 乐观并发控制</h2><p>Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。</p><p>Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p><h4 id="_1-version" tabindex="-1"><a class="header-anchor" href="#_1-version" aria-hidden="true">#</a> 1. _version</h4><p>每个文档都会自动创建一个 _version （版本）号，当文档被修改时版本号递增。Elasticsearch 使用这个 version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p><p>原理：可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。修改前获取的版本号，修改后，如果发现版本好变了，就会修改失败。</p><h4 id="_2-外部系统版本控制" tabindex="-1"><a class="header-anchor" href="#_2-外部系统版本控制" aria-hidden="true">#</a> 2. 外部系统版本控制</h4><p>一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p><p>如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp —那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号</p><p>原理：Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前_version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。</p><p>外部版本号不仅在索引和删除请求是可以指定，而且在 创建 新文档时也可以指定。</p>',24),h=[t];function n(d,_){return e(),r("div",null,h)}const p=a(c,[["render",n],["__file","5-7.文档处理.html.vue"]]);export{p as default};
