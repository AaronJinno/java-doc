import{_ as i,r as a,o as c,c as l,a as p,b as n,d as s,w as o,e as d}from"./app-0fd18ae5.js";const r={},u=d(`<h2 id="i-list-接口" tabindex="-1"><a class="header-anchor" href="#i-list-接口" aria-hidden="true">#</a> Ⅰ. List 接口</h2><h4 id="_1-介绍" tabindex="-1"><a class="header-anchor" href="#_1-介绍" aria-hidden="true">#</a> 1. 介绍</h4><p>List接口为Collection接口的子接口，常称为：动态数组</p><ul><li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组；</li><li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li></ul><h4 id="_2-list接口的实现类" tabindex="-1"><a class="header-anchor" href="#_2-list接口的实现类" aria-hidden="true">#</a> 2. List接口的实现类</h4><p>List接口是Collection的子接口，该接口有三个实现类</p><ul><li>Collection 接口 ：单列数据，定义了存取一组对象的方法的集合 <ul><li>List： 存储有序的、可重复的数据。 --&gt;“动态”数组 <ul><li><strong>ArrayList</strong>、LinkedList、Vector</li></ul></li></ul></li></ul><h5 id="_2-1-arraylist-【主要使用】" tabindex="-1"><a class="header-anchor" href="#_2-1-arraylist-【主要使用】" aria-hidden="true">#</a> 2.1 ArrayList 【主要使用】</h5><ul><li>作为List接口的主要实现类；一般情况下用这个</li><li>线程不安全的，效率高；</li><li>底层使用Object[] elementData存储</li></ul><h5 id="_2-2-linkedlist" tabindex="-1"><a class="header-anchor" href="#_2-2-linkedlist" aria-hidden="true">#</a> 2.2 LinkedList</h5><ul><li>对于频繁的插入、删除操作，使用此类效率比ArrayList高；</li><li>底层使用双向链表存储。</li></ul><h5 id="_2-3-vector" tabindex="-1"><a class="header-anchor" href="#_2-3-vector" aria-hidden="true">#</a> 2.3 Vector</h5><ul><li>作为List接口的古老实现类；</li><li>线程安全的，效率低；</li><li>底层使用Object[] elementData存储</li></ul><h2 id="ii-源码分析" tabindex="-1"><a class="header-anchor" href="#ii-源码分析" aria-hidden="true">#</a> Ⅱ. 源码分析</h2><h4 id="_1-arraylist源码分析" tabindex="-1"><a class="header-anchor" href="#_1-arraylist源码分析" aria-hidden="true">#</a> 1. ArrayList源码分析</h4><h5 id="_1-1-构造器" tabindex="-1"><a class="header-anchor" href="#_1-1-构造器" aria-hidden="true">#</a> 1.1 构造器</h5><p>底层创建了长度是10的Object[]数组elementData</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_1-2-add操作" tabindex="-1"><a class="header-anchor" href="#_1-2-add操作" aria-hidden="true">#</a> 1.2 add操作</h5><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//相当于 elementData[0] = new Interger(123);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_1-3-扩容" tabindex="-1"><a class="header-anchor" href="#_1-3-扩容" aria-hidden="true">#</a> 1.3 扩容</h5><p>如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//连续添加10次数据</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第11次添加数据</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-4-带参的构造器" tabindex="-1"><a class="header-anchor" href="#_1-4-带参的构造器" aria-hidden="true">#</a> 1.4 带参的构造器</h5><p>扩容是非常消耗资源的，因此尽量不要扩容，建议开发中使用带参的构造器：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数就是容量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_1-5-jdk8中-arraylist的变化" tabindex="-1"><a class="header-anchor" href="#_1-5-jdk8中-arraylist的变化" aria-hidden="true">#</a> 1.5 JDK8中，ArrayList的变化</h5><p>在JDK8时，ArrayList的底层做了一些改变。</p><p>初始化时，底层<code>Object[] elementData</code>初始化为<code>{}</code>。并没有创建长度为10的数组，而是在第一次add的时候，底层才创建了长度10的数组，并将数据加到<code>elementData[0]</code>，后续的添加和扩容操作与JDK8之前一样。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//底层是个空的Object[]</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第一次调用add(),才真正创建了数组</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-6-总结" tabindex="-1"><a class="header-anchor" href="#_1-6-总结" aria-hidden="true">#</a> 1.6 总结</h5><p>jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</p><h4 id="_2-linkedlist" tabindex="-1"><a class="header-anchor" href="#_2-linkedlist" aria-hidden="true">#</a> 2. LinkedList</h4><p>LinkedList是典型的双向链表结构，数据的添加、移除等操作，也是双向链表的基本操作。</p><h5 id="_2-1-实例化" tabindex="-1"><a class="header-anchor" href="#_2-1-实例化" aria-hidden="true">#</a> 2.1 实例化</h5><p>内部声明了Node类型的first（上一个Node）和last（下一个Node）属性，默认值为null</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">LinkedList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_2-2-add添加数据" tabindex="-1"><a class="header-anchor" href="#_2-2-add添加数据" aria-hidden="true">#</a> 2.2 add添加数据</h5><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将123封装到Node中，创建了Node对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_2-3-node的定义" tabindex="-1"><a class="header-anchor" href="#_2-3-node的定义" aria-hidden="true">#</a> 2.3 Node的定义</h5><p>体现了LinkedList的双向链表的说法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
     <span class="token class-name">E</span> item<span class="token punctuation">;</span>
     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>
     <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-vector" tabindex="-1"><a class="header-anchor" href="#_3-vector" aria-hidden="true">#</a> 3. Vector</h4><h5 id="_3-1-说明" tabindex="-1"><a class="header-anchor" href="#_3-1-说明" aria-hidden="true">#</a> 3.1 说明</h5><p>Vector已经被放弃了，开发时不会用。</p><p>Vector虽然是线程安全的，但是我们需要线程安全问题时，也不用用它，而是使用synchronizedList对ArrayList数据进行处理，取得线程安全的ArrayList。</p><h5 id="_3-2-源码简介" tabindex="-1"><a class="header-anchor" href="#_3-2-源码简介" aria-hidden="true">#</a> 3.2 源码简介</h5><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。</p><h2 id="iii-list方法" tabindex="-1"><a class="header-anchor" href="#iii-list方法" aria-hidden="true">#</a> Ⅲ. List方法</h2><p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。并对Collection的很多方法进行了重载。</p>`,50);function k(h,v){const e=a("ExternalLinkIcon"),t=a("RouterLink");return c(),l("div",null,[u,p("p",null,[n("详见："),s(t,{to:"/java/func/2.JDK.util%E5%8C%85/2-4.List-Map.html",target:"_blank"},{default:o(()=>[n("内置函数>List & Map"),s(e)]),_:1})])])}const b=i(r,[["render",k],["__file","6-4.List.html.vue"]]);export{b as default};
