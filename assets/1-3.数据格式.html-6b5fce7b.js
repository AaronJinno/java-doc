import{_ as t,o as e,c as a,e as i}from"./app-66068f58.js";const d="/java-doc/img/sql/es/1-3-1.jpg",l="/java-doc/img/sql/es/1-3-2.jpg",r="/java-doc/img/sql/es/1-3-3.jpg",n={},c=i('<h2 id="数据格式" tabindex="-1"><a class="header-anchor" href="#数据格式" aria-hidden="true">#</a> 数据格式</h2><p>Elasticsearch 是面向文档型数据库，一条数据在这里就是一个文档。</p><h4 id="_1-elasticsearch-与-mysql对比" tabindex="-1"><a class="header-anchor" href="#_1-elasticsearch-与-mysql对比" aria-hidden="true">#</a> 1. ElasticSearch 与 MySQL对比</h4><p>为了方便理解，将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比</p><figure><img src="'+d+'" alt="1-3-1" tabindex="0" loading="lazy"><figcaption>1-3-1</figcaption></figure><h4 id="_3-数据类型简介" tabindex="-1"><a class="header-anchor" href="#_3-数据类型简介" aria-hidden="true">#</a> 3. 数据类型简介</h4><p>ES 里的 Index 可以看做一个库，而 Types 相当于表，Documents 则相当于表的行。</p><p>这里 Types 的概念已经被逐渐弱化，现在版本的ES中已经没有Type这个概念了。</p><h2 id="正排索引" tabindex="-1"><a class="header-anchor" href="#正排索引" aria-hidden="true">#</a> 正排索引</h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>ElasticSearch采用的是倒排索引，在此之前先了解下正排索引。</p></div><h4 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1.概述</h4><p>又称正向索引，当用户发起查询时（假设查询为一个关键词），搜索引擎会扫描索引库中的所有文档，找出所有包含关键词的文档，这样依次从文档中去查找是否含有关键词的方法叫做正向索引。</p><h4 id="_2-正向索引的结构" tabindex="-1"><a class="header-anchor" href="#_2-正向索引的结构" aria-hidden="true">#</a> 2. 正向索引的结构</h4><figure><img src="'+l+'" alt="1-3-2" tabindex="0" loading="lazy"><figcaption>1-3-2</figcaption></figure><h4 id="_3-正向索引解析" tabindex="-1"><a class="header-anchor" href="#_3-正向索引解析" aria-hidden="true">#</a> 3. 正向索引解析</h4><p>我们查询数据时，输入的是<code>关键字</code>,搜索引擎会扫描库中包含该关键字的所有文档，然后返回文档的id，通过id获取文档，我们就可以查询到结果了。</p><h4 id="_4-正向索引的缺点" tabindex="-1"><a class="header-anchor" href="#_4-正向索引的缺点" aria-hidden="true">#</a> 4. 正向索引的缺点</h4><p>对于文档的查询来说，一个站点存在的文档可能会非常多，这样遍历的索引结构效率低下，无法满足用户需求。</p><p>因此才有了对文档搜索效率更高的倒排索引。</p><h2 id="关键字-文档矩阵" tabindex="-1"><a class="header-anchor" href="#关键字-文档矩阵" aria-hidden="true">#</a> 关键字-文档矩阵</h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>先了解下关键字与文档之间的关系。</p></div><p>单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型。</p><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h4><p>如下几个文档：</p><ul><li>d1：马斯克创建了SpaceX</li><li>d2：SpaceX 星舰下个月发射</li><li>d3：马斯克说将亲自指挥星舰的发射</li></ul><p>此时，用户将以马斯克、SpaceX和星舰进行查询，关键字与文档的矩阵为：</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">d1</th><th style="text-align:center;">d2</th><th style="text-align:center;">d3</th></tr></thead><tbody><tr><td style="text-align:center;">马斯克</td><td style="text-align:center;">√</td><td style="text-align:center;"></td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">SpaceX</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">星舰</td><td style="text-align:center;"></td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr></tbody></table><h4 id="矩阵解读" tabindex="-1"><a class="header-anchor" href="#矩阵解读" aria-hidden="true">#</a> 矩阵解读</h4><ul><li>横向：表示哪些文档包含了该关键字，d1和d3包含了 <code>马斯克</code> 这个关键字</li><li>纵向：表示每个单独的文档包含了哪些关键字，如果d1包含了马斯克和SpaceX</li></ul><h4 id="搜索引擎的索引" tabindex="-1"><a class="header-anchor" href="#搜索引擎的索引" aria-hidden="true">#</a> 搜索引擎的索引</h4><p>搜索引擎的索引其实就是实现 <code>关键字-矩阵</code>的具体数据结构。可以有不同的方式来实现上述概念模型</p><ul><li>正排索引：创建的索引是文档的id，搜索的过程是遍历每一个文档，比对是否有所要查询的关键字，如果有就记录文档的id，最后返回所有的文档id。 <ul><li>然后通过文档id获取对应的文档作为结果呈现。</li><li>这种方式非常的低效</li></ul></li><li>倒排索引：为所有关键字创建索引，关键字对应的值就是包含该关键字的所有文档id。搜索的过程是直接通过索引拿到关键字对应的文档id。 <ul><li>然后通过id获取对应的文档作为结果呈现。</li><li>这种方式是最佳的方案，ES就采用了这种方案。</li></ul></li><li>其他方式：签名文件、后缀树等，这些方式的效率也都不如倒排索引。</li></ul><h2 id="倒排索引" tabindex="-1"><a class="header-anchor" href="#倒排索引" aria-hidden="true">#</a> 倒排索引</h2><h4 id="_1-概述-1" tabindex="-1"><a class="header-anchor" href="#_1-概述-1" aria-hidden="true">#</a> 1. 概述</h4><p>倒排索引(Inverted Index)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。</p><h4 id="_2-倒排索引的结构" tabindex="-1"><a class="header-anchor" href="#_2-倒排索引的结构" aria-hidden="true">#</a> 2. 倒排索引的结构</h4><p>为了增加效率，搜索引擎会把正向索引变为反向索引（倒排索引）即把“文档→单词”的形式变为“单词→文档”的形式。倒排索引具体机构如下:</p><ul><li>单词1→文档1的ID；文档2的ID；文档3的ID…</li><li>单词2→文档1的ID；文档4的ID；文档7的ID…</li></ul><h4 id="_3-组成" tabindex="-1"><a class="header-anchor" href="#_3-组成" aria-hidden="true">#</a> 3. 组成</h4><p>倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p><ul><li>单词词典(Lexicon)：搜索引擎的索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li><li>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</li><li>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</li></ul><figure><img src="'+r+'" alt="1-3-3" tabindex="0" loading="lazy"><figcaption>1-3-3</figcaption></figure><h4 id="_4-倒排索引的简单实现示例" tabindex="-1"><a class="header-anchor" href="#_4-倒排索引的简单实现示例" aria-hidden="true">#</a> 4. 倒排索引的简单实现示例</h4><p>如下几个文档：</p><ul><li>d1：马斯克创建了SpaceX</li><li>d2：SpaceX 星舰下个月发射</li><li>d3：马斯克说将亲自指挥星舰的发射</li></ul><p>通过这5个文档建立简单的倒排索引:</p><table><thead><tr><th style="text-align:center;">单词id</th><th style="text-align:center;">关键字（单词）</th><th style="text-align:center;">倒排列表</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">马斯克</td><td style="text-align:center;"><code>{1,3}</code></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">SpaceX</td><td style="text-align:center;"><code>{1,2}</code></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">星舰</td><td style="text-align:center;"><code>{2,3}</code></td></tr></tbody></table><p>首先要用分词系统将文档自动切分成单词序列，这样就让文档转换为由单词序列构成的数据流，并对每个不同的单词赋予唯一的单词编号(WordID)，并且每个单词都有对应的含有该单词的文档列表即倒排列表。</p><h5 id="略微复杂的倒排列表" tabindex="-1"><a class="header-anchor" href="#略微复杂的倒排列表" aria-hidden="true">#</a> 略微复杂的倒排列表</h5><p>下面介绍一种更加复杂，包含信息更多的倒排索引。</p><table><thead><tr><th style="text-align:center;">单词id</th><th style="text-align:center;">关键字（单词）</th><th style="text-align:center;">倒排列表<code>(文档id;TF;&lt;Pos&gt;)</code></th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">马斯克</td><td style="text-align:center;">(1;1;&lt;1&gt;),(3;1;&lt;1&gt;)</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">SpaceX</td><td style="text-align:center;">(1;1;&lt;7&gt;),(2;1;&lt;1&gt;)</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">星舰</td><td style="text-align:center;">(2;1;&lt;7&gt;),(3;1;&lt;10&gt;)</td></tr></tbody></table><ul><li>TF：单词在文档中出现的次数</li><li>Pos: 单词在文档中出现的位置，也就是字符顺序</li></ul><p>这个表格展示了更加复杂的倒排索引，前两列不变，第三列倒排索引包含的信息为(文档ID，单词频次，&lt;单词位置&gt;)</p>',53),h=[c];function s(o,p){return e(),a("div",null,h)}const x=t(n,[["render",s],["__file","1-3.数据格式.html.vue"]]);export{x as default};
