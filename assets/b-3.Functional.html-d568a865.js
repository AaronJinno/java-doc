import{_ as a,o as n,c as e,e as i}from"./app-8ecbe62b.js";const t="/java-doc/img/java/javase/b-3-1.jpg",c="/java-doc/img/java/javase/b-3-2.jpg",d={},l=i(`<h2 id="i-函数式接口" tabindex="-1"><a class="header-anchor" href="#i-函数式接口" aria-hidden="true">#</a> Ⅰ. 函数式接口</h2><p>只包含一个抽象方法的接口，称为函数式接口。</p><h4 id="functional-的意义" tabindex="-1"><a class="header-anchor" href="#functional-的意义" aria-hidden="true">#</a> Functional 的意义</h4><p>Java是纯面向对象的语言，失去了面向过程（面向函数）的灵活性，比如PHP语言可以直接定义函数，使用函数，以函数为单位提供一个简单的独立的功能。</p><p>而Java不能直接定义函数，所有函数必须以方法的形式属于某个类，这就不够灵活了，而函数式接口就补气了这个短板，以函数式接口的形式模拟了面向函数的特点。</p><p>函数式接口本质上是穷举了所有函数的格式，不同的函数，格式上只有参数和返回值的区别，即多少个参数，有无返回值，返回值是怎么获取的。</p><p>因此函数式接口就是一个载体，用来执行一个函数，Java为不同格式的函数提供了不同类型的内置接口，根据需求选择符合要求（参数和返回值）的接口，实现他的方法，写出需要的功能，就OK了。</p><h4 id="_1-functional-介绍" tabindex="-1"><a class="header-anchor" href="#_1-functional-介绍" aria-hidden="true">#</a> 1. Functional 介绍</h4><h5 id="函数式接口的特点" tabindex="-1"><a class="header-anchor" href="#函数式接口的特点" aria-hidden="true">#</a> 函数式接口的特点</h5><p>由接口名、形参列表、函数名组成。</p><h5 id="如何使用函数式接口" tabindex="-1"><a class="header-anchor" href="#如何使用函数式接口" aria-hidden="true">#</a> 如何使用函数式接口</h5><p>我们需要一个功能，为一个功能创建一个类太浪费了。</p><p>我们可以利用函数式接口，寻找或定义一个参数符合的接口。然后利用Lambda的方式调用即可，函数体直接在使用的时候定义。</p><h5 id="函数式接口要定义多少" tabindex="-1"><a class="header-anchor" href="#函数式接口要定义多少" aria-hidden="true">#</a> 函数式接口要定义多少</h5><p>函数式接口本质上只是一个载体，用来执行函数体的载体，本身毫无意义。</p><p>但是由于方法是有参数限制的（数量和类型），因此我们需要定义多个函数式接口，这些接口的区别就是参数不一样，可以很简单的穷举出需要多少个函数式接口。</p><h5 id="内置函数式接口" tabindex="-1"><a class="header-anchor" href="#内置函数式接口" aria-hidden="true">#</a> 内置函数式接口</h5><p>在java.util.function包下定义了Java 8 的丰富的函数式接口。</p><p>包含4中常用的函数式接口，和一些不常用的。也就是Java替我们穷举好了，我们直接使用即可。</p><h4 id="_2-注解" tabindex="-1"><a class="header-anchor" href="#_2-注解" aria-hidden="true">#</a> 2. 注解</h4><p>@FunctionalInterface</p><p>该注解表示下面要定义的接口为：函数式接口；这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p><h4 id="_3-自定义函数式接口" tabindex="-1"><a class="header-anchor" href="#_3-自定义函数式接口" aria-hidden="true">#</a> 3. 自定义函数式接口</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-lambda与创建functional对象" tabindex="-1"><a class="header-anchor" href="#_4-lambda与创建functional对象" aria-hidden="true">#</a> 4. Lambda与创建Functional对象</h4><p>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p><p>用匿名实现类表示的都可以用Lambda表达式来写。</p><h4 id="_5-缺点" tabindex="-1"><a class="header-anchor" href="#_5-缺点" aria-hidden="true">#</a> 5. 缺点</h4><p>每次使用都要写方法体，太繁琐了，在支持函数式编程的语言了，都是提前定义好方法，随用随调，方法体都省了。</p><p>解决方案：方法引用。</p><h2 id="ii-内置functional" tabindex="-1"><a class="header-anchor" href="#ii-内置functional" aria-hidden="true">#</a> Ⅱ. 内置Functional</h2><p>Java内部已经将参数的类型穷举好了，提供了很多内置的Functional，直接用即可。</p><h4 id="_1-java内置四大核心functional" tabindex="-1"><a class="header-anchor" href="#_1-java内置四大核心functional" aria-hidden="true">#</a> 1. Java内置四大核心Functional</h4><figure><img src="`+t+'" alt="b-3-1" tabindex="0" loading="lazy"><figcaption>b-3-1</figcaption></figure><ul><li>消费型：提供一个参数，什么都不返回：参数被消耗了 <ul><li><code>Consumer&lt;T&gt; void accept(T t)</code></li></ul></li><li>供给型：不提供参数，返回了一个值：供给了一个值 <ul><li><code>Supplier&lt;T&gt; T get()</code></li></ul></li><li>函数型：提供参数，参数类型是对象T，返回值类型是对象R。 <ul><li><code>Function&lt;T,R&gt; R apply(T t)</code></li></ul></li><li>断定型：提供一个参数，进行判断，返回boolean：进行一些参数的断定 <ul><li><code>Predicate&lt;T&gt; boolean test(T t)</code></li></ul></li></ul><h4 id="_2-其他类型functional" tabindex="-1"><a class="header-anchor" href="#_2-其他类型functional" aria-hidden="true">#</a> 2. 其他类型Functional</h4><figure><img src="'+c+'" alt="b-3-2" tabindex="0" loading="lazy"><figcaption>b-3-2</figcaption></figure>',37),s=[l];function o(r,h){return n(),e("div",null,s)}const u=a(d,[["render",o],["__file","b-3.Functional.html.vue"]]);export{u as default};
