---
title: "2-2. 属性与方法"
date: 2023-06-03
---
## Ⅰ. 属性
#### 1. 属性声明语法
```java
修饰符 数据类型 属性名 = 初始化值;
public String age = 10;
```
- 修饰符
    - 权限修饰符：private、缺省、protected、public（详见封装）
    - 其他修饰符：static、final（见后续章节）
- 数据类型：任何基本数据类型(如int、Boolean) 或 任何引用数据类型。
    - 包括：属性的类型可以是一个类（修饰符将表示一个对象，对象也是引用数据类型）。
- 属性名：属于标识符，符合命名规则和规范即可。
- 初始化值：可以选择给变量一个初始化值，如果没有初始化值，会采用数据类型的默认值。

#### 2. 属性与局部变量的对比
- 属性（成员变量）：声明在类中的变量
- 局部变量：只在局部作用域有效的变量
    - 方法内、方法形参、构造器内、构造器形参、代码块内
##### 2.1 相同点
- 定义变量的格式：数据类型  变量名 = 变量值
    - 属性还会多个权限控制符
- 先声明，后使用
- 变量都有其对应的作用域 

##### 2.2 不同点
![2-2-1](/img/java/javase/2-2-1.jpg)
- 在类中声明的位置的不同
    - 属性：直接定义在类的一对{}内
    - 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
- 关于权限修饰符的不同
    - 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省、protected  --->封装性
    - 局部变量：不可以使用权限修饰符。
- 默认初始化值的情况    
    - 属性：类的属性，根据其类型，都有默认初始化值（和数组元素的默认值一样）。
        - 整型（byte、short、int、long）：0
        - 浮点型（float、double）：0.0
        - 字符型（char）：0  （或'\u0000'）
        - 布尔型（boolean）：false
        - 引用数据类型（类、数组、接口）：null
    - 局部变量：没有默认初始化值。意味着，我们在调用局部变量之前，一定要显式赋值。
        - 特别地：形参在调用时，我们赋值即可。
- 在内存中加载的位置：
    - 属性：加载到堆空间中（非static）
    - 局部变量：加载到栈空间
#### 3. 对属性可以赋值的位置
- ①默认初始化
- ②显式初始化
- ③构造器中初始化
- ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值
- ⑤在代码块中赋值

执行的先后顺序：① - ② =⑤ - ③ - ④；②跟⑤谁在前就先执行谁，一般②在前

## Ⅱ. 方法
#### 1. 概述
方法：描述类应该具有的功能。

功能封装为方法的目的是，可以实现代码重用，简化代码。Java里的方法不能独立存在，所有的方法必须定义在类里。

![2-2-1](/img/java/javase/2-2-1.jpg)

#### 2. 方法的分类
```java
权限修饰符 其他关键字 返回值类型  方法名(形参列表){
    方法体
    return 返回值;//可选
}
//暂时不考虑：static、final、abstract关键字
```
- 权限修饰符：Java规定的4种权限修饰符：private、public、缺省、protected （详见封装）
- 返回值：分为有返回值的和没返回值的
    - 有返回值：必须在方法声明时，指定返回值的类型。同时，方法中，需要使用 return关键字来返回指定类型的变量或常量：“return 数据”。
        - 可以return一个表达式，只要这个表达式的结果是一个值。
    - 没有返回值：如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。
        - 比如在条件判断中，对不满足条件的参数，直接return，结束程序，不继续执行了。
- 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
- 形参列表：方法可以声明0个，1个，或多个形参。
    - 格式：数据类型1  形参1,数据类型2 形参2,...
    - 注意：形参不能有默认值
- 方法体：方法功能的体现。

#### 3. return关键字
使用在方法体中，有以下作用
- 结束方法
- 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。

注意：return关键字后面不可以声明执行语句（会直接报错），但可以是有结果的表达式。

#### 4. 方法的调用
##### 4.1 调用在main所在类中声明的方法
在main所在类中声明的普通方法（非static），不能在main中直接调用，也需要先建立对象，再进行调用
```java
public class Person{
    public static void main(String [] args){
        Person p1 = new Person(); //依然需要new对象
        System.out.println(p1.say());
    }
    public String say(){
        return "hello";
    }
}
```
##### 4.2 注意
- 方法被调用一次，就会执行一次
- 没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。
- 定义方法时，方法的结果应该返回给调用者，交由调用者处理
- 方法中只能调用方法或属性，不可以在方法内部定义方法。

#### 5. 方法访问类的成员 
方法中，可以调用当前类的属性或方法，包括调用自己（递归）。方法中也可以定义变量，但注意不能定义方法。

语法：直接用就行，没有特殊语法，在调用时可以对属性进行修改
```java
class hello {
  public static void main(String[] args) {
    Person p = new Person();
    p.grow();//我是jinno我现在11岁[属性值被方法修改了]
    p.grow();//我是jinno我现在12岁
  }
}
class Person{
  int age = 10;
  String uname = "jinno";
  
  public void grow(){
      age++;
      talk();
  }
  public void talk(){
      System.out.println("我是"+uname+"我现在"+age+"岁");
  }
}
```
#### 6. 递归方法
:::tip
详见：数据结构与算法>递归
:::
一个方法体内调用它自身。

方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

示例：计算1-100之间所有自然数的和
```java
//使用循环
int sum = 0;
for (int i = 1; i <= 100; i++) {
  sum += i;
}

//使用递归函数
public int getSum(int n) {// 3
    if (n == 1) {
      return 1;
    } else {
      return n + getSum(n - 1);
    }
}
```


## Ⅲ. 方法的重载
#### 1. overload：重载
在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可（跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！）。

重载的判断方式：两同一不同
- 两同：同一个类、相同方法名
- 不同：参数列表不同
    - 参数个数不同
    - 参数类型不同：参数是有顺序的；

#### 2. 重载的调用
调用方法时，是通过方法名和参数列表来确定调用哪一个方法的。

即通过法名 ---> 参数列表确定某一个指定的方法。

#### 3. 重载示例
```java
public void getInfo(int id){...}
public void getInfo(String id){...}
private void getInfo(String id,Char flag){...}
```

## Ⅳ. 参数传递
#### 1. 概念
方法必须由其所在类或对象调用才有意义。方法是可以有参数的：
- 形参：方法声明时的参数
- 实参：方法调用时实际传给形参的参数值

#### 2. 参数的数据类型
方法的参数可以是任意数据类型。
- 基础数据类型
- 引用数据类型：包括对象作为参数（数据类型是类）。

#### 3. 参数值的传递机制
Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。

##### 3.1 基本数据类型
参数赋给形参的是实参真实存储的数据值，传递完之后，两个变量互不干扰。

示例：交换两个变量（基本变量）的值。
```java
public class Test{
    public static void main(String[] args){
        int m = 10;
        int n = 20;
        Test test = new Test()
        test.swap(m,n);
        System.out.println(m+n); //10,20
    } 
    public void swap(int m,int n){
        int temp = m ;
        m = n;
        n = temp;
    }
}
```
错误分析：我们将m,n传递给方法后，方法的形参被赋予了m,n的值，方法中操作的是形参中的m,n，形参中的m,n和原始数据m,n是没有关联的，所以这个交换值的函数失败了。可以使用return将修改后的数据返回。

##### 3.2 引用数据类型
如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。我们经常会用到将一个对象作为参数。

示例：交换两个变量的值。
```java
class Test{
    public void Swap(Data data){
        int temp = data.m ;
        data.m = data.n;
        data.n = temp;
    }
}
class Data{
    int m = 10;
    int n = 20;
}
```
这时上面的需求被实现了。

#### 4. 可变个数形参的方法
可变个数形参（Varargs：variable number or argumengts）机制：允许直接定义能和多个实参相匹配的形参。

##### 4.1 使用说明
格式1：方法名(参数的类型 ...参数名)

格式2：方法名(参数的类型[] 参数名) ；这个写法不推荐，这是JDK5.0以前的写法
```java
public void show(int i,String ...hobbyl){...}
```
- 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。
- 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
- 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存（可变个数形参的第二种写法）。
- 如果还有其他参数，可变个数形参在方法的形参中，必须声明在末尾
- 可变个数形参在方法的形参中,最多只能声明一个可变形参。
- 当调用方法时，传递的参数有符合条件的非可变形参方法，就优先调用。

##### 4.2 遍历可变形参
可以在方法中，使用for循环遍历可变个数形参。
```java
public void show(String ... strs){
    for(int i = 0;i < strs.length;i++){
      System.out.println(strs[i]);
    }
}
```
##### 4.3 注意事项
可变形参的两种写法，java都会认的，所以不要同时出现。

尽量使用第一种写法 ...str；避免方法重载冲突。




