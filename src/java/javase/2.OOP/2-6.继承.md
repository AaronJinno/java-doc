---
title: "2-6. 继承"
date: 2023-06-03
---
## Ⅰ. extends 继承
多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

#### 1. 语法
```java
class Subclass extends SuperClass{ }
class A extends B{}
```
- A：子类、派生类、subclass
- B：父类、超类、基类、superclass

#### 2. 继承后的效果
一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。

private属性和方法也继承了，继承过来后也是private权限。如果要使用，也需要使用getxxx和 setXxx来获取和操作；继承不能破坏封装性。

子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends：延展、扩展

#### 3. 继承的意义
- 继承的出现减少了代码冗余，提高了代码的复用性。‘
- 便于功能的扩展
- 继承的出现让类与类之间产生了关系，为之后多态性的使用，提供了前提

注意：不要仅为了获取其他类中某个功能而去继承

#### 4. 继承的规则总结
- 一个类可以被多个子类继承。
- 子类不能直接访问父类中私有的(private) 的成员变量和方法
- Java只支持单继承和多层继承，不允许多重继承；
    - 一个类只能有一个父类，可以链式继承，不能多重继承。
    - 子类父类是相对的概念（父类的父类也是父类）
- 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
- 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法
    - private修饰的成员也继承了，但是不能直接访问private修饰的成员

#### 5. Object类
- 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类
- 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类
- 意味着，所有的java类具有java.lang.Object类声明的功能。

#### 6. 权限问题
##### 6.1 子类是否能继承父类的private成员？
关于子类是否能继承父类的private成员，目前有两种说法：
- 说法一：能继承
    - 可以继承的观点是，在堆内存中，子类实例其实是，在【父类实例】的基础上，再增加子类独有的属性。因为子类实例中包含父类中的private成员，所以认为可以继承
    - 这种观点认为，封装和继承是独立的，继承是不会破坏封装性的
- 说法二：不能继承
    - 不可以继承的观点是，根据定义，子类只能通过父类方法来访问父类中的private成员，而不可以直接访问，所以认为不可以继承

##### 6.2 底层解析
创建子类对象时，除了将本类所有的成员复制一份到内存外，还会将父类所有的成员复制一份，子类对象访问继承来的属性和方法时，访问的就是继承来的。

对于父类中的private成员，子类实例也会同样复制一份（这也是为什么有观点认为private成员能继承）。不过这个继承来的private成员，子类是无法直接访问的，必须借助父类的getXxx、setXxx方法才能访问（这也是为什么有观点认为private成员是无法继承的）。

##### 6.3 子类访问父类中的private成员
需要父类实现了private成员的getXxx和setXxx方法，子类继承了这些方法后，就可以通过调用这些方法来实现。
```java
[子类继承父类private成员的测试:]
class Father{
    private int age = 88;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

class Son extends Father{
    public void info(){
        //System.out.println(age); //直接访问继承到的父类的private属性，会报错
        System.out.println(getAge()); //通过继承的父类的getAge方法获取
        setAge(50); //通过继承的父类的setAge方法来设置
        System.out.println(getAge());
    }
}
```

## Ⅱ. override 重写
#### 1. 定义
在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。

在程序执行时，子类的方法将覆盖父类的方法。约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法。也就是说，子类可以创建一个跟父类相同的方法，并根据子类的需求创建不同的方法体。

相同指的是：子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。

#### 2. 重写的要求
##### 2.1 访问修饰符
子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。

特殊情况：子类不能重写父类中声明为private权限的方法
##### 2.2 返回值
- void：父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void。
- 引用类型：父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
- 基本数据类型：父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
##### 2.3 异常
子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。详见异常。
##### 2.4 静态方法的处理
子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不报错，但不叫重写）。

因为static方法是属于类的，子类无法覆盖父类的方法。

#### 3. 可变参数的重写
拥有可变参数，依然可以进行重写。

PS：以下示例涉及到多态：
```java
class Father{
    public void add(int a, int ...arr){
        System.out.println("add-father")
    }
}
class Son extends Father{
    public void add(int a, int[] arr){
        System.out.println("add-son")
    }
    public void add(int a,int b,int c){
        System.out.println("add-son2");
    }
}

Son s1 = new Son();
s1.add(1,2,3)//add-son2
Fatehr s2 = new Son();//多态
s2.add(1,2,3);//add-son1
```
- 有可变参数的子类add方法重写了有可变参数的父类add；
-  我们执行`s1.add(1,2,3)`时，优先寻找的是参数为3（优先找固定参数的）的方法；
- 因此s1调用时，输出add-son2；
- s2是产生了多态，父类的引用指向子类的方法，因此s2调用add时会调用子类中重写的add方法。

#### 4. 关于父类中的属性
子类可以重写父类中的方法，但是不能重写父类中的属性。

当子类创建了和父类中相同的属性时，仅仅是在子类中新增了一个同类的属性，并没有重新。
访问时，默认访问的是子类的同名属性，要想访问父类中的同名属性就要使用Super关键字了。

## Ⅲ. Super
#### 1. Super的作用
在Java类中使用super来调用父类中的指定成员：
- super可用于访问父类中定义的属性
- super可用于调用父类中定义的成员方法
- super可用于在子类构造器中调用父类的构造器

#### 2. super：调用父类属性和方法
我们可以在子类的方法或构造器中。通过使用 `super.属性` 或 `super.方法` 的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略 `super.`。除非遇到特殊情况（父子类之间出现了同名的方法或属性）。
```java
super.id;
public void say(){
    super.say();
    System.out.println("son:say");
}
```
##### 2.1 子类调用父类同名属性
当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用`super.属性` s的方式，表明调用的是父类中声明的属性。
```java
//例如：子类和父类都声明了num这个属性,在父类中需要同时访问这两个属性
class Son extends Father{
    int num = 20;//父类也有这个属性,值为10
    public void getNum(){
        System.out.println(this.num);//20.这个是子类中的num,this可以省略
        System.out.println(super.num);//10.这个是父类中的num，super必须不能省略
    }
}
```
##### 2.2 子类调用父类同名方法
当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。
```java
class Son extends Father{
    public void say(String world){ //假如父类也有这个方法
        super.say(world); //调用父类中的say
        System.out.println("Son's"+world);
    }
}
```
##### 2.3 属性和方法查找的过程分析
当我们在一个类中调用属性或方法时：
- ①先从本类中查找是否有该属性或方法，找到了就使用，并不会去父类中查找
- ②当本类中没有找到时，就自动去父类中寻找，相当于自动加了个super.
- ③当父类和子类中拥有相同的属性或方法时，这里执行①就停止了，因此想使用父类的元素，就要手动的加上super（当然，子类和父类可以同时使用，同时使用时，super必加，this随意）。

#### 3. super调用构造器
我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器（虽然调用了父类的构造器，但是内存中还是只创建了子类的一个对象）。

无论通过哪个构造器创建子类对象，需要保证先初始化父类；目的是当子类继承父类后，继承父类中所有的属性和方法，因此子类必须知道父类如何为对象进行初始化。
```java
class Son extends Fathe{
    String name;
    public Son(String name,String fa){
        super.Father(fa);
        this.name = name;
    }
}
```
##### 3.1 声明位置
"super(形参列表)"的使用，必须声明在子类构造器的首行！

##### 3.2 默认的super
在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()

##### 3.3 super和this：对构造器的调用
- this.构造器是调用本类的其他构造器，this.super是调用父类的构造器
- "this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
- 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

##### 3.4 父类没有空构造器的情况
如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译报错

解析：子类是一定会调用父类的构造器的，我们不手动调用，他也会自动隐式调用了一个空参的父类构造器。当我们在父类中定义了非空参构造器时，父类中的空参构造器就会被删除。这时候如果子类没有使用super显式的调用父类中的非空参构造器，就会报错。

方案：在类中写非空参构造器时，手动写一个空参空方法体的构造器，防止被继承后子类报错。

#### 4. super与this的区别
![2-6-1](/img/java/javase/2-6-1.jpg)


## Ⅳ. 子类实例化过程
#### 1. 从结果上看
子类继承父类以后，就获取了父类中声明的属性和方法。

创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

#### 2. 从过程上看
当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。

注意：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。








