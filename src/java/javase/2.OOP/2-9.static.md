---
title: "2-9. static"
date: 2023-06-03
---
## Ⅰ. static介绍
#### 1. static关键字的使用
static是静态修饰符，用来修饰属性、方法、代码块和内部类的。

#### 2. static的背景
当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。

#### 3. 类属性与类方法
- 类属性：类属性作为该类各个对象之间共享的变量。
    - 在设计类时, 分析哪些属性不因对象的不同而改变 ，将这些属性设置为类属性。相应的方法设置为类方法。
- 类方法：如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法 ，从而简化了方法的调用。

#### 4. 被static修饰后的成员具备的特点
- 随着类的加载而加载
- 优先于对象存在
- 修饰的成员，被所有对象所共享
- 访问权限允许时，可不创建对象，直接被类调用


## Ⅱ. 静态属性
#### 1. 说明
静态属性，又称为静态变量、类变量。

被static修饰的属性就是静态属性，因此类的属性就分为：静态属性和非静态属性了。
```java
Class Person{
    static String nation;
}
Person p1 = new Person();
Person p2 = new Person();
p1.nation = "China";
System.out.println(p2.nation);//China;p1赋的值，p2也能取到
p2.nation = "Japan";
System.out.println(p1.nation);//Japan;p2改的值，p1也受影响
```
- 静态变量（类变量）：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。
- 非静态变量（实例变量）：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。

#### 2. 静态变量的声明
如下：访问修饰符和static的顺序可以调换。
```java
class ClassName{
    static 访问修饰符 属性名;//也可以初始化
}
```

#### 3. 静态变量的加载
静态变量是随着类的加载而加载，静态变量的加载要早于对象的创建。由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。因此一个类的不同实例拥有的静态变量是同一个。

#### 4. 静态变量的使用
由于静态变量的加载早于对象，因此可以通过"类.静态变量"的方式进行调用。\
```java
Person.country = "USA";//直接使用类名访问静态变量
```

## Ⅲ. 静态方法

#### 1. 概述
使用static修饰的方法，就是静态方法（与之相对的是非静态方法）。

静态方法也是随着类的加载而加载的。
#### 2. 静态方法的声明
```java
public static 返回值类型 方法名(形参列表){
    ...
}
class Person{
    static String nation = "China";
    public static String getNation(){
        return nation;//return Person.nation;
    }
} 
```
#### 3. 静态方法的调用
因为加载类时已经有静态方法了，因此可以直接通过类名调用静态方法。
```java
Person.getNation();//直接用类调用静态方法
```
#### 4. 静态方法与非静态方法的对比
静态方法中只能调用静态的方法和静态属性。

非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

#### 5. 注意事项
- 在静态的方法内，不能使用this关键字（this指向的是对象）、super关键字（super指的是当前对象的父类，也要先有对象）。
- 关于静态属性和静态方法的使用，可以从生命周期的角度去理解。

#### 6. 如何判断是否要声明static
- 属性
    - 属性是可以被多个对象所共享的，不会随着对象的不同而不同的
    - 类中的常量也常常声明为static
- 方法
    - 操作静态属性的方法，通常设置为static的（静态成员的生命周期同步）。
    - 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections
        - 方便直接用类调用

## Ⅳ. 单例模式
:::tip
详见：设计模式>单例模式
:::

#### 1. 单例模式核心
所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。

由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

#### 2. 实现方式1： 饿汉式
- 私有化类的构造器：阻止类外随便造对象
- 内部创建类的对象，并保存为静态属性
- 提供公共的静态方法，返回累的对象。
```java
class Bank{
  //1.私有化类的构造器
  private Bank(){}
  //2.内部创建类的对象
  //4.要求此对象也必须声明为静态的
  private static Bank instance = new Bank();
  //3.提供公共的静态的方法，返回类的对象
  public static Bank getInstance(){
    return instance;
  }
}
Bank bank1 = Bank.getInstance();
Bank bank2 = Bank.getInstance();
System.out.println(bank1 == bank2);//true
```

#### 3. 实现方式2：懒汉式
和饿汉式差不多，这里变成了在方法中调用构造器
```java
class Order{
  //1.私有化类的构造器
  private Order(){}
  //2.声明当前类对象，没有初始化
  //4.此对象也必须声明为static的
  private static Order instance = null;
  
  //3.声明public、static的返回当前类对象的方法
  public static Order getInstance(){
    if(instance == null){
      instance = new Order();
    }
    return instance;
  }
}
```
#### 4. 饿汉式和懒汉式的对比
- 饿汉式
    - 优点：对象加载时间过长。
    - 缺点：饿汉式是线程安全的
- 懒汉式
    - 优点：延迟对象的创建。
    - 缺点：线程不安全（无法应对高并发）；需要进行多线程的修改【详见：多线程】。

#### 5. 单例模式的使用场景
- 网站的计数器，一般也是单例模式实现，否则难以同步。
- 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
- 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。
- Application 也是单例的典型应用
-  Manager (任务管理器)就是很典型的单例模式
- Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。

