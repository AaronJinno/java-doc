---
title: 5-3. 分片控制
date: 2023-06-28
---
控制文档与分片之间的匹配关系

## 路由计算
集群有多个分片，不同的分片里数据是不同的，当索引一个文档的时候，文档会被存储到一个主分片中，ES是如何决定放入哪个分片呢？

由于储存的数据是为了以后查询使用，所以不会随机存入用一个分片，否则查询的时候就不知道去哪个分片查了。

#### ES的算法
ES有自己的算法来决定文档存储的分片位置，如下：
```js
shard = hash(routing) % primary_shards_num
```
- routing：一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值
- primary_shards_num：主分片的数量

routing 通过hash 函数生成一个数字，然后这个数字再除以number_of_primary_shards后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。

储存数据和查询数据时，采用同样的算法，就能在查询时找到正确的分片了。

#### 固定主分片苏联
要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。

#### routing参数
所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。

一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。


## 分片控制简介
假设有一个集群由三个节点组成。 它包含一个叫 emps 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点。

![5-3-1](/img/sql/es/5-3-1.jpg)

我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知
道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。

#### 协调节点
如果将所有的请求发送到固定的节点上，该节点就是协调节点(coordinating node) 

#### 轮询
当发送请求的时候，为了扩展负载，更好的做法是轮询集群中所有的节点。


## 写流程
对文档的增删请求都是写操作，写操作必须在主分片上面完成之后才能被复制到相关的副本分片
####  文档 写操作 的具体流程
![5-3-2](/img/sql/es/5-3-2.jpg)

- 客户端向 Node 1（协调节点） 发送文档的增删请求。
    - 可以是任意节点作为协调节点，这里假设是Node 1
- 协调节点通过路由计算，确定文档属于分片 0，请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。
- Node 3 在主分片上面执行请求，进行写操作
- 主分片写完后，将请求并行转发到 Node 1 和 Node 2 的副本分片上。
- 一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功
- 客户端获取反馈

#### 改变流程
有一些可选的请求参数可以改变默认的流程。

暂略，不建议这么做，


## 读（查询）流程
可以从主分片或者从其它任意副本分片检索文档

#### 文档 读（检索）操作的具体流程
![5-3-3](/img/sql/es/5-3-3.jpg)

- 客户端向 Node 1（协调节点） 发送获取文档的请求
- 节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 
    - 在这种情况下，会进行轮询，假设它将请求转发到 Node 2 。
- Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。

#### 协调节点的协调
在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。


## 更新流程
更新一个文档结合了先前说明的读取和写入流程

#### 文档 更新 操作的具体流程
![5-3-4](/img/sql/es/5-3-4.jpg)

- 客户端向 Node 1（协调节点） 发送文档更新请求。
- Node 1 使用文档的 _id 来确定文档属于分片 0，将请求转发到主分片所在的 Node 3
- Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。
- 如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成

#### 副本的更改
当主分片把更改转发到副本分片时， 它不会转发更新请求，而是转发完整文档的新版本。

## 多文档操作流程
和单文档操作的流程原理是一样的。

协调节点将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转
发到每个参与节点。

协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返
回给客户端

#### 多文档 查询 的具体步骤
- 客户端向协调节点（假设是Node1）发送多个文档的查询请求（mget）
- Node 1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。
- 一旦收到所有答复， Node 1 构建响应并将其返回给客户端。


#### 多文档 写操作 的具体步骤
- 客户端向协调节点（假设是Node1）发送多个文档的写操作请求（bulk）
- Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。
- 主分片一个接一个按顺序执行每个操作。
- 当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 
- 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。
