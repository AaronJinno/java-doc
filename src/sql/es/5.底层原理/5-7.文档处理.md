---
title: 5-7. 文档冲突
date: 2023-06-28
---
## 文档冲突介绍
#### 1. 冲突产生原因
当对文档进行修改时，会读取原文档，修改后，会重新索引新文档。不过ES的修改并非是单线程的，可能存在多个人同时修改文档。

虽然ES储存的只是提供于搜索的数据，主要数据存在于MySQL，且同时修改一个文档的概率很小。但某些场景下非常影响体验。

#### 2. 场景示例
比如一个商品促销场景，使用 Elasticsearch 存储商品库存的数量， 每卖一个商品的时候，Elasticsearch 中将库存数量减少（促销场景下，一秒钟会卖出很多）。

如下图：产生了多个web程序修改ES的场景

![5-7-1](/img/sql/es/5-7-1.jpg)

问题：web_1 对 stock_count 所做的更改已经丢失，因为 web_2 不知道它的 stock_count 的拷贝已经过期。 结果我们会认为有超过商品的实际数量的库存，因为卖给顾客的库存商品并不存在。

变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。


#### 3. 解决方案
在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：
- 悲观并发控制：这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。
- 乐观并发控制：Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何
解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。

## 乐观并发控制
Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。

Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。

#### 1. _version
每个文档都会自动创建一个 _version （版本）号，当文档被修改时版本号递增。Elasticsearch 使用这个 version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。

原理：可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。修改前获取的版本号，修改后，如果发现版本好变了，就会修改失败。

#### 2.  外部系统版本控制
一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。

如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp —那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号

原理：Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前_version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。

外部版本号不仅在索引和删除请求是可以指定，而且在 创建 新文档时也可以指定。
