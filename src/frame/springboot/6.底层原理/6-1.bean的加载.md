---
title: 6-1. bean的加载方式
date: 2023-07-07
---
:::tip
bean是Spring框架的基础部分，这里做一个总结，方便理解Spring Boot的自动装配。
:::

:::info Bean是干嘛的 ？
Bean就是被加载到内存中的类。

我们启动一个Web程序，该程序需要持续提供服务。
- 性能：启动时，Tomcat将基本所有用到的类（其实是类的对象）都加载到了内存中，且是单例的，提供服务时，用到哪个类（对象）就去内存中拿，不用现场new。
- 开发便利：将一个类设置为Bean，他就被加入内存了，也就是该类的对象已经创建了，用到这个类直接注入即可，不用麻烦的先引入再new。

Bean对于性能和开发便利帮助都非常大，是Spring框架的核心和基础。
::::


## xml Bean配置文件
在专门配置bean的配置文件中，手动指定哪些类要成为bean，在`<bean/>`给出bean的类名，Spring内部会根据反射机制加载class。

bean配置文件示例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--xml方式声明自己开发的bean-->
    <bean id="cat" class="Cat"/>
    <bean class="Dog"/>

    <!--xml方式声明第三方开发的bean-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>
    <bean class="com.alibaba.druid.pool.DruidDataSource"/>
    <bean class="com.alibaba.druid.pool.DruidDataSource"/>
</beans>
```

## 注解+xml扫描
方式1 需要将spring管控的bean全部写在xml文件中，非常麻烦。在类上面使用注解，哪一个类要受到spring管控，就在那个类上加，还可以顺带起一个bean的名字（id）。

#### 共有4个注解可用
- @Component：通用的
- @Service：给Service用的
- @Controller：给Controller用的
- @Repository：给Repository

上面四个注解作用是一样的，不同的名字只是用来标注该类逻辑上的作用。

#### 注解使用示例
```java
//该类被加入了Bean，且起了一个名字叫tom，默认名字其实是类名
@Component("tom")
public class Cat {
    ... 
}
```

#### 加载第三方Bean
无法在第三方提供的技术源代码中去添加上述4个注解，当需要加载第三方开发的bean的时候，可以创建专门的配置类加载第三方Bean。
```java
@Component//先将该配置文件加入Bean管理
public class DbConfig { 
    
    @Bean //使用@Bean注解式该方法的返回值加入Bean
    public DruidDataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        return ds;
    }
}
```

#### 扫描bean
上面提供的仅仅是bean的声明，spring并不会主动感知他们，想让Spring发现这些注解并加入Bean管理，就需要在xml配置文件中配置Spring扫描包含`Bean注解`的包。
```xml
<!-- 这个配置文件，还是Bean的xml配置文件 -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
    ">
    <!--指定扫描加载bean的位置-->
    <context:component-scan base-package="com.sgugo.bean,com.sgugo.config"/>
</beans>
```

## 注解+Spring配置类
#### 用Java配置类取代XML配置类
N3里的 写XML配置扫描包太low了。XML的功能很简单，Spring还提供了使用Java格式的Spring配置来取代XML格式的Bean配置。

同时，也可以直接在Spring配置文件中定义方法配置第三方类。

```java
@Configuration //定义为Spring配置类
// @ComponentScan用来指定指定要扫描的包
@ComponentScan({com.sgugo.bean,com.sgugo.config})
public class SpringConfig3 { // 类名随便起，重要的是上面的注解

    // 如果不需要加载第三方Bean，这里直接定义成空类就OK
    // 这里可以定义N个方法用来加载第三方Bean
    @Bean
    public DogFactoryBean dog(){
        return new DogFactoryBean();
    }
}
```

#### FactoryBean
spring提供了一个接口FactoryBean接口，可以看作是创建Bean的 *工厂模式*。实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。

意义和工厂模式类似，在返回Bean前做一些初始化操作，比如返回一个连接Redis的类，不能直接调用空参构造将对象返回，而是要先检测Redis服务是否正常，然后读取配置信息，进行Redis连接，然后再返回。

如下列，造出来的bean并不是RedisFactoryBean，而是Redis，且可在返回Bean前进行初始化。

```java
public class RedisFactoryBean implements FactoryBean<Redis> {
    @Override
    public Redis getObject() throws Exception {
        //创建实例前对Redis服务进行连接测试
        //...

        Redis redis = newRedis(...);

        //返回Bean前进行加强操作，比如写个日志

        return d;
    }

    @Override
    public Class<?> getObjectType() {
        return Redis.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}


//上面的工厂Bean类通常使用@Bean的方式进行加载
@Configuration 
@ComponentScan({com.sgugo.bean,com.sgugo.config})
public class SpringConfig3 {
    @Bean
    public DogFactoryBean dog(){
        return new DogFactoryBean();
    }
}
```
#### proxyBeanMethods
用来控制Bean单例的，默认就开启了。

## 使用@Import
通过扫描的方式将设置了注解的类加入Bean是个粒度比较大的导入方式，有可能会扫描到一些用不到的包，甚至可能触发包冲突（好的命名规范非常难得）。

而@Import的加载方式是一种精准的Bean加载方式。只需要在Spring配置类注解的参数中写上加载的类对应的.class即可。

#### 用途
这种方式非常麻烦，唯一的优点是可以指定加载，@Import注解在特殊场景很有用，比如要加载Bean的类没有使用@Component修饰。

对于无侵入编程（源码里不出现框架的痕迹），类上面没有设置Bean的注解。


#### 使用示例
```java
@Import({Dog.class,DbConfig.class})
public class SpringConfig4 {
    ...
}

//除了加载bean，还可以使用@Import注解加载配置类
@Import(DogFactoryBean.class)
public class SpringConfig4 {
    ...
}
```


## 编程式注册bean


