---
title: 1. OAuth2.0介绍
date: 2023-07-12
---
## OAuth2.0 
#### 1. 概述
OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据，OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。

它只是一个协议，实际用的是他的实现（如JWT）。

#### 2. 授权过程设计的三方
- 服务提供方：如微信，用户使用服务提供方来存储受保护的资源，如照片，视频，联系人列表。
- 用户：如微信用户，存放在服务提供方的资源的拥有者。
- 客户端：如自己开发的游戏网站，要访问服务提供方的第三方应用。


#### 3. 授权机制的设计
以微信为例

微信就是储存用户各种信息的网络服务，其他应用程序要获取微信上储存的信息，就要经过微信的“认证”。我们自己开发的程序，为了方便用户登录，需要获取用户的微信信息。

用户同意授权我们的程序访问用户放在微信的数据。

简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。

#### 4. 认证和授权的全过程
为了方便理解，以微信登录sgugo网站为例
- **用户**：用户想通过微信的方式登录sgugo，点击了微信登录。
- **sgugo**：sgugo向微信请求一个临时令牌
- **微信**：微信验证sgugo的身份，并授予一个临时令牌
- **sgugo**：sgugo获得临时令牌后，将用户引导至微信授权页面请求用户授权，在此过程中临时令牌和客户端的回调链接都将发送给微信。
- **用户**：用户点击确认（或输入密码），授权sgugo访问所请求的资源。
- **微信**：授权成功，微信引导用户返回sgugo。
- **sgugo**：sgugo根据临时令牌从微信获得了访问令牌
- **sgugo**：sgugo根据访问令牌获取微信上受保护的资源

登录成功后，sgugo签发自己的token，代替每次登陆都需要认证，并缓存微信上获取的信息作为该用户的信息（微信号、头像、地理位置等）


#### 5. 为什么要产生令牌
令牌（token）是类似密码的一种短期通信证，是只读的，在认证成功之后由服务提供者（如微信）进行签发，第三方应用可以重复利用令牌获取用户的数据，避免了每次获取数据都要认证一次。

注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期一般都设置得很短的原因。

#### 6. 令牌与密码的区别
令牌和密码都可以被认证，并获取用户的信息，但是区别很大
- 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。
- 令牌可以被数据所有者撤销，会立即失效。
- 令牌有权限范围（scope），比如，只能获取用户的头像和昵称，不能获取发信息的权限，而密码可以获得完整权限。

上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。

## 授权方式
OAuth 2.0 的标准就是 RFC 6749 文件。该文件先解释了 OAuth 是什么。

OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，资源服务器可以向客户端颁发令牌，客户端通过令牌，去请求数据。

OAuth 2.0 规定了四种获得令牌的流程，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。

### 1. 方式一：授权码
授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。【最常见，安全度最高】

#### 特点
它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。
#### 操作步骤
- 步骤一：A网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。
```js
https://b.com/oauth/authorize?
  response_type=code& //该参数表示要求返回授权码(code)
  client_id=CLIENT_ID& //该参数让B知道是谁在请求
  redirect_uri=CALLBACK_URL& //该参数是B接受会拒绝请求后的跳转网站
  scope=read //该参数表示要求的授权范围(只读)
```
- 步骤二：用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。
```js
https://a.com/callback?code=AUTHORIZATION_CODE //code参数就是授权码
```
- 步骤三：A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。
```js
https://b.com/oauth/token?
 client_id=CLIENT_ID& //该参数和client_secret参数用来让B确认A的身份
 client_secret=CLIENT_SECRET& //该参数是保密的，只能在后端发请求
 grant_type=authorization_code& //该参数的值用来说明授权的方式(授权码)
 code=AUTHORIZATION_CODE& //该参数就是上一部拿到的授权码
 redirect_uri=CALLBACK_URL //该参数是令牌颁发后的回调地址
```
- 步骤四：B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。如下，JSON 数据中，access_token字段就是令牌，A网站在后端拿到了。
```json
{    
  "access_token":"ACCESS_TOKEN",
  "token_type":"bearer",
  "expires_in":2592000,
  "refresh_token":"REFRESH_TOKEN",
  "scope":"read",
  "uid":100101,
  "info":{...}
}
```
#### 图示
![1-1](/img/su/oauth/1-1.jpg)

#### 为什么加个授权码
加个授权码更加安全，比隐藏式要安全一些

获取授权码的方式是通过浏览器跳页(get请求)，返回的授权码展示在地址栏，安全性不高。而获取令牌可以使用post请求。另外，因为授权码与发起请求的URL是关联的，所以另一个网站使用你的授权码是无法成功得到令牌的。

#### redirect_uri 的安全意义
redirect_uri只能是已经注册的域名，这样就可以防止A网站的信息被窃取，也就是即使你窃取了A的client_id，甚至client_secret，只要你没有控制A网站，你还是拿不到token。

### 2. 方式二：隐藏式
有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）

#### 步骤
- 步骤一：A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。
```js
https://b.com/oauth/authorize?
  response_type=token&  //该参数为token，表示要求直接返回令牌。
  client_id=CLIENT_ID&
  redirect_uri=CALLBACK_URL&
  scope=read
```
- 步骤二：用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。【直接在前端拿到令牌】
```js
https://a.com/callback#token=ACCESS_TOKEN
```
#### 图示

![1-2](/img/su/oauth/1-2.jpg)


#### 注意
令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在"中间人攻击"的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。

这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。


### 3. 方式三：密码式
如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。
#### 使用场景
同个集团旗下的多个品牌之间进行通信。

这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。

#### 步骤
- 步骤一：A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。
```js
https://oauth.b.com/token?
  grant_type=password& //授权方式("密码式")
  username=USERNAME&  //用户名
  password=PASSWORD& //密码
  client_id=CLIENT_ID
```
- 步骤二：B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。

### 4. 方式四：凭证式
凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。

这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。

#### 步骤
- 步骤一：A 应用在命令行向 B 发出请求
```js
https://oauth.b.com/token?
  grant_type=client_credentials& //凭证形式
  client_id=CLIENT_ID& //和下面的参数一起用于确认A的身份
  client_secret=CLIENT_SECRET
```
- 步骤二：B 网站验证通过以后，直接返回令牌



## 使用令牌
#### 令牌的使用
A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。

此时，每个发到 API 的请求（服务方），都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。
```js
curl -H "Authorization: Bearer ACCESS_TOKEN" \
"https://api.b.com" //ACCESS_TOKEN就是拿到的令牌。
```
#### 更新令牌
令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。具体做法如下：

- B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。
```js
https://b.com/oauth/token?
  grant_type=refresh_token& //该参数表示要更新令牌
  client_id=CLIENT_ID&   //和下面的参数一起用于确认身份
  client_secret=CLIENT_SECRET&
  refresh_token=REFRESH_TOKEN //用于更新令牌的令牌
```
- B 网站验证通过以后，就会颁发新的令牌。

#### 签发本站token
由于我们已经保存了用户信息，因此就可以用此信息作为用户再次登录的凭证，但是由于用户信息是会变的，因此我们只是短暂储存。

比如，微信登录后，我们就向用户的客户端签发一个token，该token7日内有效，7日内用户可以直接使用该token进行登录，哪怕我们的微信token已经过期了，该token依然有用，等我们自己的token过期时，就让用户再次登录，我们通过微信号判断是不是已经存在的用户，并更新用户的头像之类的信息。


## Github授权示例
:::tip
最常用的授权方式是授权码式，因此这里采用授权码式为例，具体授权的过程要查看对方程序的API进行对接，这里只是大致模拟一下流程。
:::
需求：登录时，使用github作为第三方登录验证。

用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。以使用github方式登录其他网站为例，流程如下

- A 网站让用户跳转到 GitHub。
- GitHub 要求用户登录，然后询问"A 网站要求获得 xx 权限，你是否同意？"
- 用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。
- A 网站使用授权码，向 GitHub 请求令牌。
- GitHub 返回令牌.
- A 网站使用令牌，向 GitHub 请求用户数据。

#### 1. 应用登记
一个应用要求 OAuth 授权，必须先到对方网站登记，让对方知道是谁在请求。

对于github，我们要先去github登记一下。登记后，GitHub 应该会返回客户端 ID（client ID）和客户端密钥（client secret），这就是应用的身份识别码。

#### 2. 代码
编写自己的应用代码，用与请求github的授权码和token（带上之前获取的clientID 和secret）。

编写的时候要参照github给的API

#### 3. 浏览器跳转 GitHub
显示一个链接，让用户点击跳转到githu：

这个 URL 指向 GitHub 的 OAuth 授权网址，带有两个参数：client_id告诉 GitHub 谁在请求，redirect_uri是稍后跳转回来的网址。同时GitHub 会要求用户登录，以确认用户的身份。
```js
https://github.com/login/oauth/authorize?
  client_id=7e015d8ce32370079895&
  redirect_uri=http://localhost:8080/oauth/redirect
```

#### 4. 授权码
登录后，GitHub 询问用户，该应用正在请求数据，你是否同意授权。

用户同意授权， GitHub 就会跳转到redirect_uri指定的跳转网址，并且带上授权码，跳转回来的 URL 就是下面的样子。
```js
http://localhost:8080/oauth/redirect?code=859310e7cecc9196f4af
```
后端收到这个请求以后，就拿到了授权码（code参数）。

#### 5. 后端实现
针对`/oauth/redirect`的请求，编写一个类，完成 OAuth 认证。

该类的首要作用，就是从URL取出授权码

#### 6. 令牌
拿到授权码后，后端请求github的令牌接口  
`https://github.com/login/oauth/access_token`，获取令牌，该接口需要提供三个参数
- client_id：客户端的 ID
- client_secret：客户端的密钥
- code：授权码

如果请求合法，GitHub 会返回一段 JSON 数据，里面包含了令牌accessToken。

#### 7. API数据
有了令牌以后，就可以向 githup的某些API 请求数据了。

请求的时候在 HTTP 头信息里面带上令牌Authorization: token 361507da。然后，就可以拿到用户数据，得到用户的身份。

